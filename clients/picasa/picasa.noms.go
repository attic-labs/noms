// This file was generated by nomdl/codegen.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// This function builds up a Noms value that describes the type
// package implemented by this file and registers it with the global
// type package definition cache.
func init() {
	p := types.NewPackage([]types.Type{
		types.MakeStructType("User",
			[]types.Field{
				types.Field{"Id", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Name", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Albums", types.MakeCompoundType(types.ListKind, types.MakeCompoundType(types.RefKind, types.MakeType(ref.Ref{}, 1))), false},
			},
			types.Choices{},
		),
		types.MakeStructType("Album",
			[]types.Field{
				types.Field{"Id", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Title", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Photos", types.MakeCompoundType(types.SetKind, types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"), 0))), false},
			},
			types.Choices{},
		),
	}, []ref.Ref{
		ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"),
	})
	types.RegisterPackage(&p)
}

// User

type User struct {
	_Id     string
	_Name   string
	_Albums ListOfRefOfAlbum

	ref *ref.Ref
}

func NewUser() User {
	return User{
		_Id:     "",
		_Name:   "",
		_Albums: NewListOfRefOfAlbum(),

		ref: &ref.Ref{},
	}
}

type UserDef struct {
	Id     string
	Name   string
	Albums ListOfRefOfAlbumDef
}

func (def UserDef) New() User {
	return User{
		_Id:     def.Id,
		_Name:   def.Name,
		_Albums: def.Albums.New(),
		ref:     &ref.Ref{},
	}
}

func (s User) Def() (d UserDef) {
	d.Id = s._Id
	d.Name = s._Name
	d.Albums = s._Albums.Def()
	return
}

var __typeForUser types.Type

func (m User) Type() types.Type {
	return __typeForUser
}

func init() {
	__typeForUser = types.MakeType(ref.Parse("sha1-988f3a092d1b2cfe21f48d517b28b27a3fed4e95"), 0)
	types.RegisterStruct(__typeForUser, builderForUser, readerForUser)
}

func builderForUser(values []types.Value) types.Value {
	i := 0
	s := User{ref: &ref.Ref{}}
	s._Id = values[i].(types.String).String()
	i++
	s._Name = values[i].(types.String).String()
	i++
	s._Albums = values[i].(ListOfRefOfAlbum)
	i++
	return s
}

func readerForUser(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(User)
	values = append(values, types.NewString(s._Id))
	values = append(values, types.NewString(s._Name))
	values = append(values, s._Albums)
	return values
}

func (s User) Equals(other types.Value) bool {
	return other != nil && __typeForUser.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s User) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s User) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, __typeForUser.Chunks()...)
	chunks = append(chunks, s._Albums.Chunks()...)
	return
}

func (s User) ChildValues() (ret []types.Value) {
	ret = append(ret, types.NewString(s._Id))
	ret = append(ret, types.NewString(s._Name))
	ret = append(ret, s._Albums)
	return
}

func (s User) Id() string {
	return s._Id
}

func (s User) SetId(val string) User {
	s._Id = val
	s.ref = &ref.Ref{}
	return s
}

func (s User) Name() string {
	return s._Name
}

func (s User) SetName(val string) User {
	s._Name = val
	s.ref = &ref.Ref{}
	return s
}

func (s User) Albums() ListOfRefOfAlbum {
	return s._Albums
}

func (s User) SetAlbums(val ListOfRefOfAlbum) User {
	s._Albums = val
	s.ref = &ref.Ref{}
	return s
}

// Album

type Album struct {
	_Id     string
	_Title  string
	_Photos SetOfRefOfRemotePhoto

	ref *ref.Ref
}

func NewAlbum() Album {
	return Album{
		_Id:     "",
		_Title:  "",
		_Photos: NewSetOfRefOfRemotePhoto(),

		ref: &ref.Ref{},
	}
}

type AlbumDef struct {
	Id     string
	Title  string
	Photos SetOfRefOfRemotePhotoDef
}

func (def AlbumDef) New() Album {
	return Album{
		_Id:     def.Id,
		_Title:  def.Title,
		_Photos: def.Photos.New(),
		ref:     &ref.Ref{},
	}
}

func (s Album) Def() (d AlbumDef) {
	d.Id = s._Id
	d.Title = s._Title
	d.Photos = s._Photos.Def()
	return
}

var __typeForAlbum types.Type

func (m Album) Type() types.Type {
	return __typeForAlbum
}

func init() {
	__typeForAlbum = types.MakeType(ref.Parse("sha1-988f3a092d1b2cfe21f48d517b28b27a3fed4e95"), 1)
	types.RegisterStruct(__typeForAlbum, builderForAlbum, readerForAlbum)
}

func builderForAlbum(values []types.Value) types.Value {
	i := 0
	s := Album{ref: &ref.Ref{}}
	s._Id = values[i].(types.String).String()
	i++
	s._Title = values[i].(types.String).String()
	i++
	s._Photos = values[i].(SetOfRefOfRemotePhoto)
	i++
	return s
}

func readerForAlbum(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(Album)
	values = append(values, types.NewString(s._Id))
	values = append(values, types.NewString(s._Title))
	values = append(values, s._Photos)
	return values
}

func (s Album) Equals(other types.Value) bool {
	return other != nil && __typeForAlbum.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s Album) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s Album) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, __typeForAlbum.Chunks()...)
	chunks = append(chunks, s._Photos.Chunks()...)
	return
}

func (s Album) ChildValues() (ret []types.Value) {
	ret = append(ret, types.NewString(s._Id))
	ret = append(ret, types.NewString(s._Title))
	ret = append(ret, s._Photos)
	return
}

func (s Album) Id() string {
	return s._Id
}

func (s Album) SetId(val string) Album {
	s._Id = val
	s.ref = &ref.Ref{}
	return s
}

func (s Album) Title() string {
	return s._Title
}

func (s Album) SetTitle(val string) Album {
	s._Title = val
	s.ref = &ref.Ref{}
	return s
}

func (s Album) Photos() SetOfRefOfRemotePhoto {
	return s._Photos
}

func (s Album) SetPhotos(val SetOfRefOfRemotePhoto) Album {
	s._Photos = val
	s.ref = &ref.Ref{}
	return s
}

// RefOfUser

type RefOfUser struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfUser(target ref.Ref) RefOfUser {
	return RefOfUser{target, &ref.Ref{}}
}

func (r RefOfUser) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfUser) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfUser) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfUser.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfUser) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r)
	return
}

func (r RefOfUser) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfUser.
var __typeForRefOfUser types.Type

func (r RefOfUser) Type() types.Type {
	return __typeForRefOfUser
}

func (r RefOfUser) Less(other types.OrderedValue) bool {
	return r.TargetRef().Less(other.(types.RefBase).TargetRef())
}

func init() {
	__typeForRefOfUser = types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-988f3a092d1b2cfe21f48d517b28b27a3fed4e95"), 0))
	types.RegisterRef(__typeForRefOfUser, builderForRefOfUser)
}

func builderForRefOfUser(r ref.Ref) types.RefBase {
	return NewRefOfUser(r)
}

func (r RefOfUser) TargetValue(vr types.ValueReader) User {
	return vr.ReadValue(r.target).(User)
}

// ListOfRefOfAlbum

type ListOfRefOfAlbum struct {
	l   types.List
	ref *ref.Ref
}

func NewListOfRefOfAlbum() ListOfRefOfAlbum {
	return ListOfRefOfAlbum{types.NewTypedList(__typeForListOfRefOfAlbum), &ref.Ref{}}
}

type ListOfRefOfAlbumDef []ref.Ref

func (def ListOfRefOfAlbumDef) New() ListOfRefOfAlbum {
	l := make([]types.Value, len(def))
	for i, d := range def {
		l[i] = NewRefOfAlbum(d)
	}
	return ListOfRefOfAlbum{types.NewTypedList(__typeForListOfRefOfAlbum, l...), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) Def() ListOfRefOfAlbumDef {
	d := make([]ref.Ref, l.Len())
	for i := uint64(0); i < l.Len(); i++ {
		d[i] = l.l.Get(i).(RefOfAlbum).TargetRef()
	}
	return d
}

func (l ListOfRefOfAlbum) Equals(other types.Value) bool {
	return other != nil && __typeForListOfRefOfAlbum.Equals(other.Type()) && l.Ref() == other.Ref()
}

func (l ListOfRefOfAlbum) Ref() ref.Ref {
	return types.EnsureRef(l.ref, l)
}

func (l ListOfRefOfAlbum) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, l.Type().Chunks()...)
	chunks = append(chunks, l.l.Chunks()...)
	return
}

func (l ListOfRefOfAlbum) ChildValues() []types.Value {
	return append([]types.Value{}, l.l.ChildValues()...)
}

// A Noms Value that describes ListOfRefOfAlbum.
var __typeForListOfRefOfAlbum types.Type

func (m ListOfRefOfAlbum) Type() types.Type {
	return __typeForListOfRefOfAlbum
}

func init() {
	__typeForListOfRefOfAlbum = types.MakeCompoundType(types.ListKind, types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-988f3a092d1b2cfe21f48d517b28b27a3fed4e95"), 1)))
	types.RegisterValue(__typeForListOfRefOfAlbum, builderForListOfRefOfAlbum, readerForListOfRefOfAlbum)
}

func builderForListOfRefOfAlbum(v types.Value) types.Value {
	return ListOfRefOfAlbum{v.(types.List), &ref.Ref{}}
}

func readerForListOfRefOfAlbum(v types.Value) types.Value {
	return v.(ListOfRefOfAlbum).l
}

func (l ListOfRefOfAlbum) Len() uint64 {
	return l.l.Len()
}

func (l ListOfRefOfAlbum) Empty() bool {
	return l.Len() == uint64(0)
}

func (l ListOfRefOfAlbum) Get(i uint64) RefOfAlbum {
	return l.l.Get(i).(RefOfAlbum)
}

func (l ListOfRefOfAlbum) Slice(idx uint64, end uint64) ListOfRefOfAlbum {
	return ListOfRefOfAlbum{l.l.Slice(idx, end), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) Set(i uint64, val RefOfAlbum) ListOfRefOfAlbum {
	return ListOfRefOfAlbum{l.l.Set(i, val), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) Append(v ...RefOfAlbum) ListOfRefOfAlbum {
	return ListOfRefOfAlbum{l.l.Append(l.fromElemSlice(v)...), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) Insert(idx uint64, v ...RefOfAlbum) ListOfRefOfAlbum {
	return ListOfRefOfAlbum{l.l.Insert(idx, l.fromElemSlice(v)...), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) Remove(idx uint64, end uint64) ListOfRefOfAlbum {
	return ListOfRefOfAlbum{l.l.Remove(idx, end), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) RemoveAt(idx uint64) ListOfRefOfAlbum {
	return ListOfRefOfAlbum{(l.l.RemoveAt(idx)), &ref.Ref{}}
}

func (l ListOfRefOfAlbum) fromElemSlice(p []RefOfAlbum) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

type ListOfRefOfAlbumIterCallback func(v RefOfAlbum, i uint64) (stop bool)

func (l ListOfRefOfAlbum) Iter(cb ListOfRefOfAlbumIterCallback) {
	l.l.Iter(func(v types.Value, i uint64) bool {
		return cb(v.(RefOfAlbum), i)
	})
}

type ListOfRefOfAlbumIterAllCallback func(v RefOfAlbum, i uint64)

func (l ListOfRefOfAlbum) IterAll(cb ListOfRefOfAlbumIterAllCallback) {
	l.l.IterAll(func(v types.Value, i uint64) {
		cb(v.(RefOfAlbum), i)
	})
}

func (l ListOfRefOfAlbum) IterAllP(concurrency int, cb ListOfRefOfAlbumIterAllCallback) {
	l.l.IterAllP(concurrency, func(v types.Value, i uint64) {
		cb(v.(RefOfAlbum), i)
	})
}

type ListOfRefOfAlbumFilterCallback func(v RefOfAlbum, i uint64) (keep bool)

func (l ListOfRefOfAlbum) Filter(cb ListOfRefOfAlbumFilterCallback) ListOfRefOfAlbum {
	out := l.l.Filter(func(v types.Value, i uint64) bool {
		return cb(v.(RefOfAlbum), i)
	})
	return ListOfRefOfAlbum{out, &ref.Ref{}}
}

// SetOfRefOfRemotePhoto

type SetOfRefOfRemotePhoto struct {
	s   types.Set
	ref *ref.Ref
}

func NewSetOfRefOfRemotePhoto() SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{types.NewTypedSet(__typeForSetOfRefOfRemotePhoto), &ref.Ref{}}
}

type SetOfRefOfRemotePhotoDef map[ref.Ref]bool

func (def SetOfRefOfRemotePhotoDef) New() SetOfRefOfRemotePhoto {
	l := make([]types.Value, len(def))
	i := 0
	for d, _ := range def {
		l[i] = NewRefOfRemotePhoto(d)
		i++
	}
	return SetOfRefOfRemotePhoto{types.NewTypedSet(__typeForSetOfRefOfRemotePhoto, l...), &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Def() SetOfRefOfRemotePhotoDef {
	def := make(map[ref.Ref]bool, s.Len())
	s.s.Iter(func(v types.Value) bool {
		def[v.(RefOfRemotePhoto).TargetRef()] = true
		return false
	})
	return def
}

func (s SetOfRefOfRemotePhoto) Equals(other types.Value) bool {
	return other != nil && __typeForSetOfRefOfRemotePhoto.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s SetOfRefOfRemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s SetOfRefOfRemotePhoto) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, s.Type().Chunks()...)
	chunks = append(chunks, s.s.Chunks()...)
	return
}

func (s SetOfRefOfRemotePhoto) ChildValues() []types.Value {
	return append([]types.Value{}, s.s.ChildValues()...)
}

// A Noms Value that describes SetOfRefOfRemotePhoto.
var __typeForSetOfRefOfRemotePhoto types.Type

func (m SetOfRefOfRemotePhoto) Type() types.Type {
	return __typeForSetOfRefOfRemotePhoto
}

func init() {
	__typeForSetOfRefOfRemotePhoto = types.MakeCompoundType(types.SetKind, types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"), 0)))
	types.RegisterValue(__typeForSetOfRefOfRemotePhoto, builderForSetOfRefOfRemotePhoto, readerForSetOfRefOfRemotePhoto)
}

func builderForSetOfRefOfRemotePhoto(v types.Value) types.Value {
	return SetOfRefOfRemotePhoto{v.(types.Set), &ref.Ref{}}
}

func readerForSetOfRefOfRemotePhoto(v types.Value) types.Value {
	return v.(SetOfRefOfRemotePhoto).s
}

func (s SetOfRefOfRemotePhoto) Empty() bool {
	return s.s.Empty()
}

func (s SetOfRefOfRemotePhoto) Len() uint64 {
	return s.s.Len()
}

func (s SetOfRefOfRemotePhoto) Has(p RefOfRemotePhoto) bool {
	return s.s.Has(p)
}

type SetOfRefOfRemotePhotoIterCallback func(p RefOfRemotePhoto) (stop bool)

func (s SetOfRefOfRemotePhoto) Iter(cb SetOfRefOfRemotePhotoIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(v.(RefOfRemotePhoto))
	})
}

type SetOfRefOfRemotePhotoIterAllCallback func(p RefOfRemotePhoto)

func (s SetOfRefOfRemotePhoto) IterAll(cb SetOfRefOfRemotePhotoIterAllCallback) {
	s.s.IterAll(func(v types.Value) {
		cb(v.(RefOfRemotePhoto))
	})
}

func (s SetOfRefOfRemotePhoto) IterAllP(concurrency int, cb SetOfRefOfRemotePhotoIterAllCallback) {
	s.s.IterAllP(concurrency, func(v types.Value) {
		cb(v.(RefOfRemotePhoto))
	})
}

type SetOfRefOfRemotePhotoFilterCallback func(p RefOfRemotePhoto) (keep bool)

func (s SetOfRefOfRemotePhoto) Filter(cb SetOfRefOfRemotePhotoFilterCallback) SetOfRefOfRemotePhoto {
	out := s.s.Filter(func(v types.Value) bool {
		return cb(v.(RefOfRemotePhoto))
	})
	return SetOfRefOfRemotePhoto{out, &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Insert(p ...RefOfRemotePhoto) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{s.s.Insert(s.fromElemSlice(p)...), &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Remove(p ...RefOfRemotePhoto) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{s.s.Remove(s.fromElemSlice(p)...), &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Union(others ...SetOfRefOfRemotePhoto) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{s.s.Union(s.fromStructSlice(others)...), &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) First() RefOfRemotePhoto {
	return s.s.First().(RefOfRemotePhoto)
}

func (s SetOfRefOfRemotePhoto) fromStructSlice(p []SetOfRefOfRemotePhoto) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfRefOfRemotePhoto) fromElemSlice(p []RefOfRemotePhoto) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

// RefOfAlbum

type RefOfAlbum struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfAlbum(target ref.Ref) RefOfAlbum {
	return RefOfAlbum{target, &ref.Ref{}}
}

func (r RefOfAlbum) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfAlbum) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfAlbum) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfAlbum.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfAlbum) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r)
	return
}

func (r RefOfAlbum) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfAlbum.
var __typeForRefOfAlbum types.Type

func (r RefOfAlbum) Type() types.Type {
	return __typeForRefOfAlbum
}

func (r RefOfAlbum) Less(other types.OrderedValue) bool {
	return r.TargetRef().Less(other.(types.RefBase).TargetRef())
}

func init() {
	__typeForRefOfAlbum = types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-988f3a092d1b2cfe21f48d517b28b27a3fed4e95"), 1))
	types.RegisterRef(__typeForRefOfAlbum, builderForRefOfAlbum)
}

func builderForRefOfAlbum(r ref.Ref) types.RefBase {
	return NewRefOfAlbum(r)
}

func (r RefOfAlbum) TargetValue(vr types.ValueReader) Album {
	return vr.ReadValue(r.target).(Album)
}

// RefOfRemotePhoto

type RefOfRemotePhoto struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfRemotePhoto(target ref.Ref) RefOfRemotePhoto {
	return RefOfRemotePhoto{target, &ref.Ref{}}
}

func (r RefOfRemotePhoto) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfRemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfRemotePhoto) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfRemotePhoto.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfRemotePhoto) Chunks() (chunks []types.RefBase) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r)
	return
}

func (r RefOfRemotePhoto) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfRemotePhoto.
var __typeForRefOfRemotePhoto types.Type

func (r RefOfRemotePhoto) Type() types.Type {
	return __typeForRefOfRemotePhoto
}

func (r RefOfRemotePhoto) Less(other types.OrderedValue) bool {
	return r.TargetRef().Less(other.(types.RefBase).TargetRef())
}

func init() {
	__typeForRefOfRemotePhoto = types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"), 0))
	types.RegisterRef(__typeForRefOfRemotePhoto, builderForRefOfRemotePhoto)
}

func builderForRefOfRemotePhoto(r ref.Ref) types.RefBase {
	return NewRefOfRemotePhoto(r)
}

func (r RefOfRemotePhoto) TargetValue(vr types.ValueReader) RemotePhoto {
	return vr.ReadValue(r.target).(RemotePhoto)
}
