// This file was generated by nomgen.
// To regenerate, run `go generate` in this package.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// Album

type Album struct {
	m types.Map
}

func NewAlbum() Album {
	return Album{
		types.NewMap(types.NewString("$name"), types.NewString("Album")),
	}
}

func AlbumFromVal(v types.Value) Album {
	return Album{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Album) NomsValue() types.Map {
	return s.m
}

func (s Album) Equals(p Album) bool {
	return s.m.Equals(p.m)
}

func (s Album) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Album) Title() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("title")))
}

func (s Album) SetTitle(p types.String) Album {
	return AlbumFromVal(s.m.Set(types.NewString("title"), p))
}

func (s Album) Id() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("id")))
}

func (s Album) SetId(p types.String) Album {
	return AlbumFromVal(s.m.Set(types.NewString("id"), p))
}

func (s Album) Photos() SetOfRemotePhoto {
	return SetOfRemotePhotoFromVal(s.m.Get(types.NewString("photos")))
}

func (s Album) SetPhotos(p SetOfRemotePhoto) Album {
	return AlbumFromVal(s.m.Set(types.NewString("photos"), p.NomsValue()))
}

// SetOfRemotePhoto

type SetOfRemotePhoto struct {
	s types.Set
}

type SetOfRemotePhotoIterCallback (func(p RemotePhoto) (stop bool))

func NewSetOfRemotePhoto() SetOfRemotePhoto {
	return SetOfRemotePhoto{types.NewSet()}
}

func SetOfRemotePhotoFromVal(p types.Value) SetOfRemotePhoto {
	return SetOfRemotePhoto{p.(types.Set)}
}

func (s SetOfRemotePhoto) NomsValue() types.Set {
	return s.s
}

func (s SetOfRemotePhoto) Equals(p SetOfRemotePhoto) bool {
	return s.s.Equals(p.s)
}

func (s SetOfRemotePhoto) Ref() ref.Ref {
	return s.s.Ref()
}

func (s SetOfRemotePhoto) Empty() bool {
	return s.s.Empty()
}

func (s SetOfRemotePhoto) Len() uint64 {
	return s.s.Len()
}

func (s SetOfRemotePhoto) Has(p RemotePhoto) bool {
	return s.s.Has(p.NomsValue())
}

func (s SetOfRemotePhoto) Iter(cb SetOfRemotePhotoIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(RemotePhotoFromVal(v))
	})
}

func (s SetOfRemotePhoto) Insert(p ...RemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s SetOfRemotePhoto) Remove(p ...RemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s SetOfRemotePhoto) Union(others ...SetOfRemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Union(s.fromStructSlice(others)...)}
}

func (s SetOfRemotePhoto) Subtract(others ...SetOfRemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s SetOfRemotePhoto) Any() RemotePhoto {
	return RemotePhotoFromVal(s.s.Any())
}

func (s SetOfRemotePhoto) fromStructSlice(p []SetOfRemotePhoto) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfRemotePhoto) fromElemSlice(p []RemotePhoto) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// RemotePhoto

type RemotePhoto struct {
	m types.Map
}

func NewRemotePhoto() RemotePhoto {
	return RemotePhoto{
		types.NewMap(types.NewString("$name"), types.NewString("RemotePhoto")),
	}
}

func RemotePhotoFromVal(v types.Value) RemotePhoto {
	return RemotePhoto{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s RemotePhoto) NomsValue() types.Map {
	return s.m
}

func (s RemotePhoto) Equals(p RemotePhoto) bool {
	return s.m.Equals(p.m)
}

func (s RemotePhoto) Ref() ref.Ref {
	return s.m.Ref()
}

func (s RemotePhoto) Sizes() MapOfSizeToString {
	return MapOfSizeToStringFromVal(s.m.Get(types.NewString("sizes")))
}

func (s RemotePhoto) SetSizes(p MapOfSizeToString) RemotePhoto {
	return RemotePhotoFromVal(s.m.Set(types.NewString("sizes"), p.NomsValue()))
}

func (s RemotePhoto) Title() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("title")))
}

func (s RemotePhoto) SetTitle(p types.String) RemotePhoto {
	return RemotePhotoFromVal(s.m.Set(types.NewString("title"), p))
}

func (s RemotePhoto) Id() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("id")))
}

func (s RemotePhoto) SetId(p types.String) RemotePhoto {
	return RemotePhotoFromVal(s.m.Set(types.NewString("id"), p))
}

func (s RemotePhoto) Tags() SetOfString {
	return SetOfStringFromVal(s.m.Get(types.NewString("tags")))
}

func (s RemotePhoto) SetTags(p SetOfString) RemotePhoto {
	return RemotePhotoFromVal(s.m.Set(types.NewString("tags"), p.NomsValue()))
}

func (s RemotePhoto) Geoposition() Geoposition {
	return GeopositionFromVal(s.m.Get(types.NewString("geoposition")))
}

func (s RemotePhoto) SetGeoposition(p Geoposition) RemotePhoto {
	return RemotePhotoFromVal(s.m.Set(types.NewString("geoposition"), p.NomsValue()))
}

func (s RemotePhoto) Url() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("url")))
}

func (s RemotePhoto) SetUrl(p types.String) RemotePhoto {
	return RemotePhotoFromVal(s.m.Set(types.NewString("url"), p))
}

// SetOfString

type SetOfString struct {
	s types.Set
}

type SetOfStringIterCallback (func(p types.String) (stop bool))

func NewSetOfString() SetOfString {
	return SetOfString{types.NewSet()}
}

func SetOfStringFromVal(p types.Value) SetOfString {
	return SetOfString{p.(types.Set)}
}

func (s SetOfString) NomsValue() types.Set {
	return s.s
}

func (s SetOfString) Equals(p SetOfString) bool {
	return s.s.Equals(p.s)
}

func (s SetOfString) Ref() ref.Ref {
	return s.s.Ref()
}

func (s SetOfString) Empty() bool {
	return s.s.Empty()
}

func (s SetOfString) Len() uint64 {
	return s.s.Len()
}

func (s SetOfString) Has(p types.String) bool {
	return s.s.Has(p)
}

func (s SetOfString) Iter(cb SetOfStringIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(types.StringFromVal(v))
	})
}

func (s SetOfString) Insert(p ...types.String) SetOfString {
	return SetOfString{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s SetOfString) Remove(p ...types.String) SetOfString {
	return SetOfString{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s SetOfString) Union(others ...SetOfString) SetOfString {
	return SetOfString{s.s.Union(s.fromStructSlice(others)...)}
}

func (s SetOfString) Subtract(others ...SetOfString) SetOfString {
	return SetOfString{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s SetOfString) Any() types.String {
	return types.StringFromVal(s.s.Any())
}

func (s SetOfString) fromStructSlice(p []SetOfString) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfString) fromElemSlice(p []types.String) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

// Geoposition

type Geoposition struct {
	m types.Map
}

func NewGeoposition() Geoposition {
	return Geoposition{
		types.NewMap(types.NewString("$name"), types.NewString("Geoposition")),
	}
}

func GeopositionFromVal(v types.Value) Geoposition {
	return Geoposition{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Geoposition) NomsValue() types.Map {
	return s.m
}

func (s Geoposition) Equals(p Geoposition) bool {
	return s.m.Equals(p.m)
}

func (s Geoposition) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Geoposition) Longitude() types.Float32 {
	return types.Float32FromVal(s.m.Get(types.NewString("longitude")))
}

func (s Geoposition) SetLongitude(p types.Float32) Geoposition {
	return GeopositionFromVal(s.m.Set(types.NewString("longitude"), p))
}

func (s Geoposition) Latitude() types.Float32 {
	return types.Float32FromVal(s.m.Get(types.NewString("latitude")))
}

func (s Geoposition) SetLatitude(p types.Float32) Geoposition {
	return GeopositionFromVal(s.m.Set(types.NewString("latitude"), p))
}

// User

type User struct {
	m types.Map
}

func NewUser() User {
	return User{
		types.NewMap(types.NewString("$name"), types.NewString("User")),
	}
}

func UserFromVal(v types.Value) User {
	return User{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s User) NomsValue() types.Map {
	return s.m
}

func (s User) Equals(p User) bool {
	return s.m.Equals(p.m)
}

func (s User) Ref() ref.Ref {
	return s.m.Ref()
}

func (s User) OAuthToken() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("oAuthToken")))
}

func (s User) SetOAuthToken(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("oAuthToken"), p))
}

func (s User) Name() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("name")))
}

func (s User) SetName(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("name"), p))
}

func (s User) Albums() MapOfStringToAlbum {
	return MapOfStringToAlbumFromVal(s.m.Get(types.NewString("albums")))
}

func (s User) SetAlbums(p MapOfStringToAlbum) User {
	return UserFromVal(s.m.Set(types.NewString("albums"), p.NomsValue()))
}

func (s User) Id() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("id")))
}

func (s User) SetId(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("id"), p))
}

func (s User) OAuthSecret() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("oAuthSecret")))
}

func (s User) SetOAuthSecret(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("oAuthSecret"), p))
}

// MapOfSizeToString

type MapOfSizeToString struct {
	m types.Map
}

type MapOfSizeToStringIterCallback (func(k Size, v types.String) (stop bool))

func NewMapOfSizeToString() MapOfSizeToString {
	return MapOfSizeToString{types.NewMap()}
}

func MapOfSizeToStringFromVal(p types.Value) MapOfSizeToString {
	return MapOfSizeToString{p.(types.Map)}
}

func (m MapOfSizeToString) NomsValue() types.Map {
	return m.m
}

func (m MapOfSizeToString) Equals(p MapOfSizeToString) bool {
	return m.m.Equals(p.m)
}

func (m MapOfSizeToString) Ref() ref.Ref {
	return m.m.Ref()
}

func (m MapOfSizeToString) Empty() bool {
	return m.m.Empty()
}

func (m MapOfSizeToString) Len() uint64 {
	return m.m.Len()
}

func (m MapOfSizeToString) Has(p Size) bool {
	return m.m.Has(p.NomsValue())
}

func (m MapOfSizeToString) Get(p Size) types.String {
	return types.StringFromVal(m.m.Get(p.NomsValue()))
}

func (m MapOfSizeToString) Set(k Size, v types.String) MapOfSizeToString {
	return MapOfSizeToStringFromVal(m.m.Set(k.NomsValue(), v))
}

// TODO: Implement SetM?

func (m MapOfSizeToString) Remove(p Size) MapOfSizeToString {
	return MapOfSizeToStringFromVal(m.m.Remove(p.NomsValue()))
}

func (m MapOfSizeToString) Iter(cb MapOfSizeToStringIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(SizeFromVal(k), types.StringFromVal(v))
	})
}

// Size

type Size struct {
	m types.Map
}

func NewSize() Size {
	return Size{
		types.NewMap(types.NewString("$name"), types.NewString("Size")),
	}
}

func SizeFromVal(v types.Value) Size {
	return Size{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Size) NomsValue() types.Map {
	return s.m
}

func (s Size) Equals(p Size) bool {
	return s.m.Equals(p.m)
}

func (s Size) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Size) Width() types.UInt32 {
	return types.UInt32FromVal(s.m.Get(types.NewString("width")))
}

func (s Size) SetWidth(p types.UInt32) Size {
	return SizeFromVal(s.m.Set(types.NewString("width"), p))
}

func (s Size) Height() types.UInt32 {
	return types.UInt32FromVal(s.m.Get(types.NewString("height")))
}

func (s Size) SetHeight(p types.UInt32) Size {
	return SizeFromVal(s.m.Set(types.NewString("height"), p))
}

// MapOfStringToAlbum

type MapOfStringToAlbum struct {
	m types.Map
}

type MapOfStringToAlbumIterCallback (func(k types.String, v Album) (stop bool))

func NewMapOfStringToAlbum() MapOfStringToAlbum {
	return MapOfStringToAlbum{types.NewMap()}
}

func MapOfStringToAlbumFromVal(p types.Value) MapOfStringToAlbum {
	return MapOfStringToAlbum{p.(types.Map)}
}

func (m MapOfStringToAlbum) NomsValue() types.Map {
	return m.m
}

func (m MapOfStringToAlbum) Equals(p MapOfStringToAlbum) bool {
	return m.m.Equals(p.m)
}

func (m MapOfStringToAlbum) Ref() ref.Ref {
	return m.m.Ref()
}

func (m MapOfStringToAlbum) Empty() bool {
	return m.m.Empty()
}

func (m MapOfStringToAlbum) Len() uint64 {
	return m.m.Len()
}

func (m MapOfStringToAlbum) Has(p types.String) bool {
	return m.m.Has(p)
}

func (m MapOfStringToAlbum) Get(p types.String) Album {
	return AlbumFromVal(m.m.Get(p))
}

func (m MapOfStringToAlbum) Set(k types.String, v Album) MapOfStringToAlbum {
	return MapOfStringToAlbumFromVal(m.m.Set(k, v.NomsValue()))
}

// TODO: Implement SetM?

func (m MapOfStringToAlbum) Remove(p types.String) MapOfStringToAlbum {
	return MapOfStringToAlbumFromVal(m.m.Remove(p))
}

func (m MapOfStringToAlbum) Iter(cb MapOfStringToAlbumIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(types.StringFromVal(k), AlbumFromVal(v))
	})
}
