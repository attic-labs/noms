// This file was generated by nomdl/codegen.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

var __mainPackageInFile_sha1_00419eb_CachedRef ref.Ref

// This function builds up a Noms value that describes the type
// package implemented by this file and registers it with the global
// type package definition cache.
func init() {
	p := types.NewPackage([]types.TypeRef{
		types.MakeStructTypeRef("RemotePhoto",
			[]types.Field{
				types.Field{"Id", types.MakePrimitiveTypeRef(types.StringKind), false},
				types.Field{"Title", types.MakePrimitiveTypeRef(types.StringKind), false},
				types.Field{"Url", types.MakePrimitiveTypeRef(types.StringKind), false},
				types.Field{"Geoposition", types.MakeTypeRef(ref.Parse("sha1-6d5e1c54214264058be9f61f4b4ece0368c8c678"), 0), false},
				types.Field{"Sizes", types.MakeCompoundTypeRef(types.MapKind, types.MakeTypeRef(ref.Ref{}, 1), types.MakePrimitiveTypeRef(types.StringKind)), false},
				types.Field{"Tags", types.MakeCompoundTypeRef(types.SetKind, types.MakePrimitiveTypeRef(types.StringKind)), false},
			},
			types.Choices{},
		),
		types.MakeStructTypeRef("Size",
			[]types.Field{
				types.Field{"Width", types.MakePrimitiveTypeRef(types.UInt32Kind), false},
				types.Field{"Height", types.MakePrimitiveTypeRef(types.UInt32Kind), false},
			},
			types.Choices{},
		),
	}, []ref.Ref{
		ref.Parse("sha1-6d5e1c54214264058be9f61f4b4ece0368c8c678"),
	})
	__mainPackageInFile_sha1_00419eb_CachedRef = types.RegisterPackage(&p)
}

// RemotePhoto

type RemotePhoto struct {
	m   types.Map
	ref *ref.Ref
}

func NewRemotePhoto() RemotePhoto {
	return RemotePhoto{types.NewMap(
		types.NewString("Id"), types.NewString(""),
		types.NewString("Title"), types.NewString(""),
		types.NewString("Url"), types.NewString(""),
		types.NewString("Geoposition"), NewGeoposition(),
		types.NewString("Sizes"), NewMapOfSizeToString(),
		types.NewString("Tags"), NewSetOfString(),
	), &ref.Ref{}}
}

type RemotePhotoDef struct {
	Id          string
	Title       string
	Url         string
	Geoposition GeopositionDef
	Sizes       MapOfSizeToStringDef
	Tags        SetOfStringDef
}

func (def RemotePhotoDef) New() RemotePhoto {
	return RemotePhoto{
		types.NewMap(
			types.NewString("Id"), types.NewString(def.Id),
			types.NewString("Title"), types.NewString(def.Title),
			types.NewString("Url"), types.NewString(def.Url),
			types.NewString("Geoposition"), def.Geoposition.New(),
			types.NewString("Sizes"), def.Sizes.New(),
			types.NewString("Tags"), def.Tags.New(),
		), &ref.Ref{}}
}

func (s RemotePhoto) Def() (d RemotePhotoDef) {
	d.Id = s.m.Get(types.NewString("Id")).(types.String).String()
	d.Title = s.m.Get(types.NewString("Title")).(types.String).String()
	d.Url = s.m.Get(types.NewString("Url")).(types.String).String()
	d.Geoposition = s.m.Get(types.NewString("Geoposition")).(Geoposition).Def()
	d.Sizes = s.m.Get(types.NewString("Sizes")).(MapOfSizeToString).Def()
	d.Tags = s.m.Get(types.NewString("Tags")).(SetOfString).Def()
	return
}

var __typeRefForRemotePhoto types.TypeRef

func (m RemotePhoto) TypeRef() types.TypeRef {
	return __typeRefForRemotePhoto
}

func init() {
	__typeRefForRemotePhoto = types.MakeTypeRef(__mainPackageInFile_sha1_00419eb_CachedRef, 0)
	types.RegisterFromValFunction(__typeRefForRemotePhoto, func(v types.Value) types.Value {
		return RemotePhotoFromVal(v)
	})
}

func RemotePhotoFromVal(val types.Value) RemotePhoto {
	// TODO: Do we still need FromVal?
	if val, ok := val.(RemotePhoto); ok {
		return val
	}
	// TODO: Validate here
	return RemotePhoto{val.(types.Map), &ref.Ref{}}
}

func (s RemotePhoto) InternalImplementation() types.Map {
	return s.m
}

func (s RemotePhoto) Equals(other types.Value) bool {
	return other != nil && s.Ref() == other.Ref()
}

func (s RemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s RemotePhoto) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, s.TypeRef().Chunks()...)
	chunks = append(chunks, s.m.Chunks()...)
	return
}

func (s RemotePhoto) Id() string {
	return s.m.Get(types.NewString("Id")).(types.String).String()
}

func (s RemotePhoto) SetId(val string) RemotePhoto {
	return RemotePhoto{s.m.Set(types.NewString("Id"), types.NewString(val)), &ref.Ref{}}
}

func (s RemotePhoto) Title() string {
	return s.m.Get(types.NewString("Title")).(types.String).String()
}

func (s RemotePhoto) SetTitle(val string) RemotePhoto {
	return RemotePhoto{s.m.Set(types.NewString("Title"), types.NewString(val)), &ref.Ref{}}
}

func (s RemotePhoto) Url() string {
	return s.m.Get(types.NewString("Url")).(types.String).String()
}

func (s RemotePhoto) SetUrl(val string) RemotePhoto {
	return RemotePhoto{s.m.Set(types.NewString("Url"), types.NewString(val)), &ref.Ref{}}
}

func (s RemotePhoto) Geoposition() Geoposition {
	return s.m.Get(types.NewString("Geoposition")).(Geoposition)
}

func (s RemotePhoto) SetGeoposition(val Geoposition) RemotePhoto {
	return RemotePhoto{s.m.Set(types.NewString("Geoposition"), val), &ref.Ref{}}
}

func (s RemotePhoto) Sizes() MapOfSizeToString {
	return s.m.Get(types.NewString("Sizes")).(MapOfSizeToString)
}

func (s RemotePhoto) SetSizes(val MapOfSizeToString) RemotePhoto {
	return RemotePhoto{s.m.Set(types.NewString("Sizes"), val), &ref.Ref{}}
}

func (s RemotePhoto) Tags() SetOfString {
	return s.m.Get(types.NewString("Tags")).(SetOfString)
}

func (s RemotePhoto) SetTags(val SetOfString) RemotePhoto {
	return RemotePhoto{s.m.Set(types.NewString("Tags"), val), &ref.Ref{}}
}

// Size

type Size struct {
	m   types.Map
	ref *ref.Ref
}

func NewSize() Size {
	return Size{types.NewMap(
		types.NewString("Width"), types.UInt32(0),
		types.NewString("Height"), types.UInt32(0),
	), &ref.Ref{}}
}

type SizeDef struct {
	Width  uint32
	Height uint32
}

func (def SizeDef) New() Size {
	return Size{
		types.NewMap(
			types.NewString("Width"), types.UInt32(def.Width),
			types.NewString("Height"), types.UInt32(def.Height),
		), &ref.Ref{}}
}

func (s Size) Def() (d SizeDef) {
	d.Width = uint32(s.m.Get(types.NewString("Width")).(types.UInt32))
	d.Height = uint32(s.m.Get(types.NewString("Height")).(types.UInt32))
	return
}

var __typeRefForSize types.TypeRef

func (m Size) TypeRef() types.TypeRef {
	return __typeRefForSize
}

func init() {
	__typeRefForSize = types.MakeTypeRef(__mainPackageInFile_sha1_00419eb_CachedRef, 1)
	types.RegisterFromValFunction(__typeRefForSize, func(v types.Value) types.Value {
		return SizeFromVal(v)
	})
}

func SizeFromVal(val types.Value) Size {
	// TODO: Do we still need FromVal?
	if val, ok := val.(Size); ok {
		return val
	}
	// TODO: Validate here
	return Size{val.(types.Map), &ref.Ref{}}
}

func (s Size) InternalImplementation() types.Map {
	return s.m
}

func (s Size) Equals(other types.Value) bool {
	return other != nil && s.Ref() == other.Ref()
}

func (s Size) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s Size) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, s.TypeRef().Chunks()...)
	chunks = append(chunks, s.m.Chunks()...)
	return
}

func (s Size) Width() uint32 {
	return uint32(s.m.Get(types.NewString("Width")).(types.UInt32))
}

func (s Size) SetWidth(val uint32) Size {
	return Size{s.m.Set(types.NewString("Width"), types.UInt32(val)), &ref.Ref{}}
}

func (s Size) Height() uint32 {
	return uint32(s.m.Get(types.NewString("Height")).(types.UInt32))
}

func (s Size) SetHeight(val uint32) Size {
	return Size{s.m.Set(types.NewString("Height"), types.UInt32(val)), &ref.Ref{}}
}

// MapOfSizeToString

type MapOfSizeToString struct {
	m   types.Map
	ref *ref.Ref
}

func NewMapOfSizeToString() MapOfSizeToString {
	return MapOfSizeToString{types.NewMap(), &ref.Ref{}}
}

type MapOfSizeToStringDef map[SizeDef]string

func (def MapOfSizeToStringDef) New() MapOfSizeToString {
	kv := make([]types.Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, k.New(), types.NewString(v))
	}
	return MapOfSizeToString{types.NewMap(kv...), &ref.Ref{}}
}

func (m MapOfSizeToString) Def() MapOfSizeToStringDef {
	def := make(map[SizeDef]string)
	m.m.Iter(func(k, v types.Value) bool {
		def[k.(Size).Def()] = v.(types.String).String()
		return false
	})
	return def
}

func MapOfSizeToStringFromVal(val types.Value) MapOfSizeToString {
	// TODO: Do we still need FromVal?
	if val, ok := val.(MapOfSizeToString); ok {
		return val
	}
	// TODO: Validate here
	return MapOfSizeToString{val.(types.Map), &ref.Ref{}}
}

func (m MapOfSizeToString) InternalImplementation() types.Map {
	return m.m
}

func (m MapOfSizeToString) Equals(other types.Value) bool {
	return other != nil && m.Ref() == other.Ref()
}

func (m MapOfSizeToString) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfSizeToString) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.TypeRef().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

// A Noms Value that describes MapOfSizeToString.
var __typeRefForMapOfSizeToString types.TypeRef

func (m MapOfSizeToString) TypeRef() types.TypeRef {
	return __typeRefForMapOfSizeToString
}

func init() {
	__typeRefForMapOfSizeToString = types.MakeCompoundTypeRef(types.MapKind, types.MakeTypeRef(__mainPackageInFile_sha1_00419eb_CachedRef, 1), types.MakePrimitiveTypeRef(types.StringKind))
	types.RegisterFromValFunction(__typeRefForMapOfSizeToString, func(v types.Value) types.Value {
		return MapOfSizeToStringFromVal(v)
	})
}

func (m MapOfSizeToString) Empty() bool {
	return m.m.Empty()
}

func (m MapOfSizeToString) Len() uint64 {
	return m.m.Len()
}

func (m MapOfSizeToString) Has(p Size) bool {
	return m.m.Has(p)
}

func (m MapOfSizeToString) Get(p Size) string {
	return m.m.Get(p).(types.String).String()
}

func (m MapOfSizeToString) MaybeGet(p Size) (string, bool) {
	v, ok := m.m.MaybeGet(p)
	if !ok {
		return "", false
	}
	return v.(types.String).String(), ok
}

func (m MapOfSizeToString) Set(k Size, v string) MapOfSizeToString {
	return MapOfSizeToString{m.m.Set(k, types.NewString(v)), &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfSizeToString) Remove(p Size) MapOfSizeToString {
	return MapOfSizeToString{m.m.Remove(p), &ref.Ref{}}
}

type MapOfSizeToStringIterCallback func(k Size, v string) (stop bool)

func (m MapOfSizeToString) Iter(cb MapOfSizeToStringIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(k.(Size), v.(types.String).String())
	})
}

type MapOfSizeToStringIterAllCallback func(k Size, v string)

func (m MapOfSizeToString) IterAll(cb MapOfSizeToStringIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(k.(Size), v.(types.String).String())
	})
}

type MapOfSizeToStringFilterCallback func(k Size, v string) (keep bool)

func (m MapOfSizeToString) Filter(cb MapOfSizeToStringFilterCallback) MapOfSizeToString {
	nm := NewMapOfSizeToString()
	m.IterAll(func(k Size, v string) {
		if cb(k, v) {
			nm = nm.Set(k, v)
		}
	})
	return nm
}

// SetOfString

type SetOfString struct {
	s   types.Set
	ref *ref.Ref
}

func NewSetOfString() SetOfString {
	return SetOfString{types.NewSet(), &ref.Ref{}}
}

type SetOfStringDef map[string]bool

func (def SetOfStringDef) New() SetOfString {
	l := make([]types.Value, len(def))
	i := 0
	for d, _ := range def {
		l[i] = types.NewString(d)
		i++
	}
	return SetOfString{types.NewSet(l...), &ref.Ref{}}
}

func (s SetOfString) Def() SetOfStringDef {
	def := make(map[string]bool, s.Len())
	s.s.Iter(func(v types.Value) bool {
		def[v.(types.String).String()] = true
		return false
	})
	return def
}

func SetOfStringFromVal(val types.Value) SetOfString {
	// TODO: Do we still need FromVal?
	if val, ok := val.(SetOfString); ok {
		return val
	}
	return SetOfString{val.(types.Set), &ref.Ref{}}
}

func (s SetOfString) InternalImplementation() types.Set {
	return s.s
}

func (s SetOfString) Equals(other types.Value) bool {
	return other != nil && s.Ref() == other.Ref()
}

func (s SetOfString) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s SetOfString) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, s.TypeRef().Chunks()...)
	chunks = append(chunks, s.s.Chunks()...)
	return
}

// A Noms Value that describes SetOfString.
var __typeRefForSetOfString types.TypeRef

func (m SetOfString) TypeRef() types.TypeRef {
	return __typeRefForSetOfString
}

func init() {
	__typeRefForSetOfString = types.MakeCompoundTypeRef(types.SetKind, types.MakePrimitiveTypeRef(types.StringKind))
	types.RegisterFromValFunction(__typeRefForSetOfString, func(v types.Value) types.Value {
		return SetOfStringFromVal(v)
	})
}

func (s SetOfString) Empty() bool {
	return s.s.Empty()
}

func (s SetOfString) Len() uint64 {
	return s.s.Len()
}

func (s SetOfString) Has(p string) bool {
	return s.s.Has(types.NewString(p))
}

type SetOfStringIterCallback func(p string) (stop bool)

func (s SetOfString) Iter(cb SetOfStringIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(v.(types.String).String())
	})
}

type SetOfStringIterAllCallback func(p string)

func (s SetOfString) IterAll(cb SetOfStringIterAllCallback) {
	s.s.IterAll(func(v types.Value) {
		cb(v.(types.String).String())
	})
}

type SetOfStringFilterCallback func(p string) (keep bool)

func (s SetOfString) Filter(cb SetOfStringFilterCallback) SetOfString {
	ns := NewSetOfString()
	s.IterAll(func(v string) {
		if cb(v) {
			ns = ns.Insert(v)
		}
	})
	return ns
}

func (s SetOfString) Insert(p ...string) SetOfString {
	return SetOfString{s.s.Insert(s.fromElemSlice(p)...), &ref.Ref{}}
}

func (s SetOfString) Remove(p ...string) SetOfString {
	return SetOfString{s.s.Remove(s.fromElemSlice(p)...), &ref.Ref{}}
}

func (s SetOfString) Union(others ...SetOfString) SetOfString {
	return SetOfString{s.s.Union(s.fromStructSlice(others)...), &ref.Ref{}}
}

func (s SetOfString) Subtract(others ...SetOfString) SetOfString {
	return SetOfString{s.s.Subtract(s.fromStructSlice(others)...), &ref.Ref{}}
}

func (s SetOfString) Any() string {
	return s.s.Any().(types.String).String()
}

func (s SetOfString) fromStructSlice(p []SetOfString) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfString) fromElemSlice(p []string) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = types.NewString(v)
	}
	return r
}
